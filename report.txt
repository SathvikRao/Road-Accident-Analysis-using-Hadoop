Explain in a few words, your logic for mapper.py in Task 1 * :
	Firstly we convert JSON string in each line of the input to 'dictionary' object. Then we check for NaN values in the required attributes. Then we check if the required attributes meet our conditions. Since the keys represent hour time (0-23), we want to sort the output of mapper according to hour time but since Hadoop sorts the keys treating them as strings lexographically, we map hour time as alphabets before printing. For eg: 0->A, 1->B....23->X. The values are 1.

Explain in a few words, your logic for reducer.py in Task 1 * :
	We take the sorted output from mapper as the input to our reducer. We make use of 'prev_Hour' variable to keep track of hour time being processed and 'hour_Count' variable to count the occurences of a particular hour. We read the input and convert the keys from alphabets back to numbers and store it in 'curr_Hour' and store the value in 'count' variable. If 'curr_Hour' is same as the 'prev_Hour' we increment the 'hour_Count' else we print the 'prev_Hour' and 'hour_Count' and we also reinitialise those values to 'curr_Hour' and 'count'

Explain in a few words, your logic for mapper.py in Task 2 * :
	Firstly we get the command-line-arguements and then get convert each line of the input JSON string to 'dictionary' object. We check for NaN values in the required attributes. Then we calculate the Eucledian distance between the two points and check if it is within the given threshold. We then query the server to get the 'State' and 'City' details. From observing the output of 15% dataset file we deduce that derivative cities are printed first then the main city. This can be achived by making the seperator between 'State','City' and count to have a ASCII value greater than space and less then '-'. We have used ',' as a seperator in our case and it takes care of the order of the cities while sorting lexographically. Therefore we print the output in the format "State,City,1".
	
Explain in a few words, your logic for reducer.py in Task 2 * :
	We initialise various variables to keep track of previous State_name, City_name, State_count and City_count. We read the sorted output from mapper as our input to the reducer. We read line by line and keep track of currStateName, currCityName and count in each line. If the prev State_name is same as currStateName we increment the State_count, if prev City_name is same as currCityName we increment City_count else we print the prev City_name and City_count and reinitialise those values to currCityName and count. If the prev State_name is not the same as currStateName we print the prev City_name,City_count in one line and prev State_name,State_count in next line. Then we print the name of the currState and reinitialise all prev variables to curr variables.
